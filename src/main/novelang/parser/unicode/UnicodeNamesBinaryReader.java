package novelang.parser.unicode;

import java.net.URL;
import java.io.InputStream;
import java.io.IOException;
import java.io.ByteArrayOutputStream;
import java.nio.charset.Charset;

import com.google.common.base.Preconditions;


/**
 * Reads the binary file generated by {@link novelang.build.UnicodeNamesGenerator}.
 *
 * @author Laurent Caillette
 */
/*package*/ class UnicodeNamesBinaryReader {

  private static final Charset CHARSET = Charset.forName( "UTF-8" ) ;

  private final URL resourceUrl ;

  public UnicodeNamesBinaryReader( final URL resourceUrl ) {
    this.resourceUrl = Preconditions.checkNotNull( resourceUrl ) ;
  }

  public String getName( final char character ) throws IOException {
    return readName( resourceUrl.openStream(), character ) ;
  }

  /*package*/ static String readName( final InputStream inputStream, final char character )
      throws IOException
  {
    final int firstOffset = character * 4 ;
    skipForSure( inputStream, firstOffset ) ;

    final byte[] nameOffsetAsBytes = new byte[ 4 ] ;
    if( inputStream.read( nameOffsetAsBytes ) != 4 ) {
      throw new IOException( "Could not read offset, missing bytes" ) ;
    }
    final long nameOffsetFromStart = asLong( nameOffsetAsBytes );

    if( nameOffsetFromStart == 0 ) {
      return null ;
    }

    final long relativeNameOffset = nameOffsetFromStart - firstOffset - 4 ;
    skipForSure( inputStream, relativeNameOffset ) ;

    final ByteArrayOutputStream nameBytes = new ByteArrayOutputStream() ;
    while( true ) {
      final int read = inputStream.read() ;
      if( read == 0 ) {
        break ;
      } else {
        nameBytes.write( read ) ;
      }
    }

    final String name = nameBytes.toString( CHARSET.name() ) ;
    return name ;
  }

  /*package*/ static long asLong( final byte[] nameOffsetAsBytes ) {
    Preconditions.checkArgument( nameOffsetAsBytes.length == 4 ) ;
    long nameOffsetFromStart = 0 ;
    for( int i = 0 ; i < 4 ; i ++ ) {
      nameOffsetFromStart <<= 8 ; // Does nothing at the first iteration.

      // Get rid of the sign of the byte, and'ing it with 01111111 11111111 11111111 11111111.
      final long unsignedByteAsLong = nameOffsetAsBytes[ i ]  & 0x000000FF ;
      nameOffsetFromStart |= unsignedByteAsLong;
    }
    return nameOffsetFromStart ;
  }

  private static void skipForSure( final InputStream inputStream, final long offset )
      throws IOException {
    final long skipped = inputStream.skip( offset ) ;
    if( skipped != offset ) {
      throw new IOException( "Attempted to skip " + offset + " but skipped " + skipped ) ;
    }
  }


}
