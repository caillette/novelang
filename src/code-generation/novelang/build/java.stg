group java ;

header( package ) ::= "package <package> ;"

enumName( name ) ::= "public enum <name> "

enumItem( item ) ::= <<
<if(item.punctuationSign)>
<item.name>( true )
<else>
<item.name>
<endif>
>>

enum( package, name, items, generatorName, generationTimestamp ) ::= <<
<header( package )>

import java.util.Collections ;
import java.util.Set ;
import com.google.common.base.Preconditions ;
import com.google.common.collect.Sets ;
import novelang.common.SyntacticTree ;


/**
 * Don't modify this class manually nor check it in the VCS.
 * Instead, run code generation which takes tokens from ANTLR grammar.
 * Some tokens which are not present in ANTLR grammar are added by the code generator itself.
 *
 * Generated on <generationTimestamp>
 * @author <generatorName>
 */
<enumName( name )> {
  <items : { item | <enumItem( item )>} ; separator = ", \n" > ;

  private final boolean punctuationSign ;

  private <name>() {
    punctuationSign = false ;
  }

  <name>( boolean punctuationSign ) {
    this.punctuationSign = punctuationSign ;
  }

  public boolean isPunctuationSign() {
    return punctuationSign ;
  }

  public static NodeKind ofRoot( SyntacticTree tree ) {
    return Enum.valueOf( NodeKind.class, tree.getText() ) ;
  }

  private static final Set\< String > NAMES ;
  static {
    final Set\< String > names = Sets.newHashSet() ;
    for( NodeKind nodeKind : NodeKind.values() ) {
      names.add( nodeKind.name() ) ;
    }
    NAMES = Collections.unmodifiableSet( names ) ;
  }

  public static Set\< String > getNames() {
    return NAMES ;
  }

  /**
   * Returns if a given {@code Tree} is of expected kind.
   * @param tree may be null.
   */
  public boolean isRoot( SyntacticTree tree ) {
    if( null == tree ) {
      return false ;
    }
    final String text = tree.getText();
    return
        NAMES.contains( text ) &&
        name().equals( text )
    ;
  }

  public static boolean rootHasNodeKindName( SyntacticTree tree ) {
    if( null == tree ) {
      return false ;
    }
    final String text = tree.getText() ;
    return null != tree && NAMES.contains( text ) ;
  }

  public static void ensure( SyntacticTree tree, NodeKind nodeKind ) {
    Preconditions.checkNotNull( tree ) ;
    Preconditions.checkNotNull( nodeKind ) ;
    final String nodeText = Preconditions.checkNotNull( tree.getText() ) ;
    if( ! NAMES.contains( nodeText ) ) {
      throw new RuntimeException( "Not a known node kind: '" + nodeText + "'" ) ;
    }
    if( nodeKind != ofRoot( tree ) ) {
      throw new RuntimeException( "Expected: " + nodeKind + ", got: " + nodeText ) ;
    }
  }

}
>>  


characterItem( item ) ::= <<
  '<item.declaration>'<if( item.comment )> /* <item.comment> */<endif>
>>

setOfCharacters( package, name, characters, generatorName, generationTimestamp ) ::= <<
<header( package )>

import java.util.Set ;
import com.google.common.collect.ImmutableSet ;

/**
 * Don't modify this class manually nor check it in the VCS.
 * Instead, run code generation which takes tokens from ANTLR grammar.
 *
 * Generated on <generationTimestamp>
 * @author <generatorName>
 */
public class <name> {

  private static final Set\< Character > CHARACTERS = ImmutableSet.of(
    <characters : { character | <characterItem( character )>} ; separator = ", \n" > 
  ) ;

  public static synchronized Set\< Character > getSupportedCharacters() {
    return CHARACTERS ;
  }

}
>>